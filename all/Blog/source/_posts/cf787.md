---
title: cf787
permalink: /cf/787/
categories: cf
tags: [dfs, dp, dsu]
toc: true
math: true
date: 2022-05-06 18:15:55
updated:
---

[https://codeforces.com/contest/1675](https://codeforces.com/contest/1675)

# A. Food for Animals
## 题意

给定 $a$ 个狗粮，$b$ 个猫粮，$c$ 个任意。是否能够给 $x$ 只狗、$y$ 只猫各自分配一个？

## 解答

最后分配任意的。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int a, b, c, x, y;
  std::cin >> a >> b >> c >> x >> y;

  x = std::max(x - a, 0);
  y = std::max(y - b, 0);

  std::cout << (x + y > c ? "NO\n" : "YES\n");
}
```

</details>

> 复杂度： $\mathcal O(1)$

# B. Make It Increasing
## 题意

给定数组，你可多次将某数 **整除** $2$，问能否将其变为严格单调递增的序列？ 如果有，回答最小操作次数。

## 解答

> 事实证明，不能 xjb 想特判，不然会死得很惨。

固定最后一个值不动，从后往前遍历即可。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int n;
  std::cin >> n;

  std::vector<int> a(n);
  for (auto &i : a) {
    std::cin >> i;
  }

  int ans = 0;
  for (int i = n - 2; i >= 0; --i) {
    if (!a[i + 1]) {
      return std::cout << "-1\n", void();
    } else {
      while (a[i] >= a[i + 1]) {
        a[i] >>= 1;
        ans += 1;
      }
    }
  }
  std::cout << ans << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n \lg n)$

# C. Detective Task
## 题意

房间里放了一幅画，但是被贼了。小明询问他的朋友们 **是否看到了画**，朋友们将回答 $1 / 0 / ?$
表示肯定与否、记不清了。

房间里某时刻仅有一个人，询问次序为离开次序。问有多少人可疑？

## 解答

$0 \star 1$ 出现时，可以断定一定有人说谎，因此答案为首个 $0$ 和最后一个 $1$ 的距离。

<details><summary>展开代码</summary>

```cpp
void solve() {
  std::string s;
  std::cin >> s;

  int p1 = 0, p0 = s.size() - 1;

  for (int i = 0; i < (int) s.size(); ++i) {
    if (s[i] == '0') {
      p0 = i;
      break;
    }
  }

  for (int i = (int) s.size(); i >= 0; --i) {
    if (s[i] == '1') {
      p1 = i;
      break;
    }
  }

  std::cout << std::abs(p0 - p1 + 1) << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n)$

# D. Vertical Paths
## 题意

求最少的不交链将给定的树完全覆盖。

## 解答

显然叶子个数即为所求。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int n;
  std::cin >> n;

  std::vector<int> p(n);
  std::vector<bool> leaf(n, 1);

  for (int i = 0; i < n; ++i) {
    std::cin >> p[i];
    p[i] -= 1;
    if (p[i] != i) {
      leaf[p[i]] = false;
    }
  }

  std::cout << std::count(leaf.begin(), leaf.end(), 1) << '\n';

  std::vector<bool> visited(n);

  for (int i = 0; i < n; ++i) {
    if (leaf[i]) {
      std::stack<int> ans;
      for (int j = i; !visited[j]; j = p[j]) {
        visited[j] = true;
        ans.push(j + 1);
      }
      std::cout << (int) ans.size() << '\n';
      while (ans.size()) {
        std::cout << ans.top() << " \n"[ans.size() == 1];
        ans.pop();
      }
    }
  }

  std::cout << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n)$

# E. Replace With the Previous, Minimize
## 题意

将出现的所有某字母 $x$ 都变为 $x - 1$。问这样对 $s$ 操作 $k$ 次之后，得到的最小字符串是什么？

## 解答

在改变 $c \rightarrow b \rightarrow a$ 的过程中可以将 $b, c$ 都变为 $a$。因此我们只需要考虑怎么操作某一个较大的字符。

需要字典序最小，因此考虑从左至右枚举，找到第一个大于 $k$ 的字符将其改小，小于该字符的实体都可变作 $``a"$。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int n, k;
  std::string s;

  std::cin >> n >> k >> s;

  int M = 0;
  for (int i = 0; i < n; ++i) {
    if (s[i] - 'a' > k) {
      int l = s[i] - k + M, r = s[i];
      for (auto &c : s) {
        if (c >= l && c <= r) {
          c = l;
        }
      }
      break;
    }
    M = std::max(M, s[i] - 'a');
  }

  for (auto &i : s) {
    if (i <= 'a' + M) {
      i = 'a';
    }
  }

  std::cout << s << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n)$

Bonus: 将能同时变化的点连接起来，某个联通块内的字符都变为同一种字符。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int n, k;
  std::string s;

  std::cin >> n >> k >> s;

  DSU g(26);

  for (int i = 0; i < n && k != 0; ++i) {
    int p = g.find(s[i] - 'a');
    if (!p) {
      continue;
    } else {
      while (p != 0 && k != 0) {
        g.helper(p, p - 1);
        p = g.find(p);
        k -= 1;
      }
    }
  }

  for (auto &c : s) {
    c = 'a' + g.find(c - 'a');
  }

  std::cout << s << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n \alpha(n))$

# F. Vlad and Unfinished Business
## 题意

求在树上从 $x$ 经过给定的 $k$ 个关键点到达 $y$ 的最小步数。

## 解答

不妨以 $x$ 为根，我们熟知树上两点的路是唯一的，因而要到达关键点的最优走法自然是遍历某子树的所有关键点，随后原路返回。

特殊的，$y$ 不需要折返，最终减去其深度即可。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int n, k, x, y;
  std::cin >> n >> k >> x >> y;

  x -= 1, y -= 1;

  std::vector<int> a(k);
  for (auto &i : a) {
    std::cin >> i;
    i -= 1;
  }

  a.push_back(y);
  std::vector<std::vector<int>> G(n);

  for (int i = 1, u, v; i < n; ++i) {
    std::cin >> u >> v;
    u -= 1, v -= 1;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  std::vector<int> dep(n), pre(n, -1);
  auto dfs = [&](auto &&self, int u) -> void {
    for (auto &&to : G[u]) if (to != pre[u]) {
      pre[to] = u;
      dep[to] = dep[u] + 1;
      self(self, to);
    }
  };

  dfs(dfs, x);

  int ans = 0;
  std::vector<bool> visited(n);
  visited[x] = true;

  for (auto &&p : a) {
    while (!visited[p]) {
      visited[p] = true;
      ans += 2;
      p = pre[p];
    }
  }

  ans -= dep[y];
  std::cout << ans << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n)$

# G. Sorting Pancakes
## 题意

给定一个和为 $m$ 的数组，可多次选择俩相邻元素，一个加一另一个减一。

问最少操作多少此使得数组非严格递减？

 - $m \le 250$

## 解答

用 $dp_{\{i, j, k\}}$ 表示前 $i$ 个位置、**当前和** 为 $j$、最后一个数是 $k$ 的满足题意的答案。

$$
dp_{\{i, j, k\}} = \min_{t \le k}dp_{\{i-1, j, t\}} + \left|\sum_{q = 1} ^ {i + 1}a_q - (j + k)\right|
$$

<details><summary>展开代码</summary>

```cpp
#include <bits/stdc++.h>

template<class T> inline void chmin(T &x, T y) { x = x < y ? x : y; }

int main() {
  std::cin.tie(nullptr)->sync_with_stdio(false);

  int n, m;
  std::cin >> n >> m;

  std::vector<int> a(n), s(n + 1, 0);

  for (int i = 0; i < n; ++i) {
    std::cin >> a[i];
    s[i + 1] = s[i] + a[i];
  }

  std::vector dp(n + 1, std::vector(m + 1, std::vector<int>(m + 1, 0X7F7F7F7F)));

  dp[0][0][m] = 0;

  for (int i = 0; i < n; ++i) {
    for (int j = 0; j <= m; ++j) {
      int mx = 0X7F7F7F7F;
      for (int k = m; k >= 0; --k) {
        chmin(mx, dp[i][j][k]);
        if (j + k <= m) {
          chmin(dp[i + 1][j + k][k], mx + std::abs(s[i + 1] - (j + k)));
        }
      }
    }
  }

  std::cout << *std::min_element(dp[n][m].begin(), dp[n][m].end()) << '\n';

  return 0 ^ 0;
}
```

</details>

> 复杂度： $\mathcal O(n m ^ 2)$
