---
title: cf788
permalink: /cf/788/
categories: cf
tags: [oeis, greedy, dsu, 找环, 二分, 构造, 位运算, todo, 数位背包, dp]
toc: true
math: true
date: 2022-05-07 08:23:57
updated:
sticky: 100
---

<p class="note note-danger"> 这场学弟上蓝了，很是羡慕。希望自己能加油！ </p>

[https://codeforces.com/contest/1670](https://codeforces.com/contest/1670)

# A. Prof. Slim
## 题意

给定一些数，可多次选择两个符号不同的数字并交换他们的符号，这样操作能否使数组变为非严格上升的？

 - 保证均不为 $0$

## 解答

首先需要特判本来就有序。

否则（如果同时存在正负数）我们总能将负号集中在前面，正号放在后面，随后判断是否非严格上升即可。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int n;
  std::cin >> n;

  std::vector<int> a(n);

  int cnt = 0;

  for (auto &i : a) {
    std::cin >> i;
    cnt += i < 0;
  }

  if (std::is_sorted(a.begin(), a.end(), std::less<>())) {
    return std::cout << "YES\n", void();
  }

  std::transform(a.begin(), a.end(), a.begin(), [&](int n) { return std::abs(n); });
  std::transform(a.begin(), a.begin() + cnt, a.begin(), std::negate<>());

  if (std::is_sorted(a.begin(), a.end(), std::less<>())) {
    std::cout << "YES\n";
  } else {
    std::cout << "NO\n";
  }
}
```

</details>

> 复杂度： $\mathcal O(n)$

# B. Dorms War
## 题意

给定字符串 $s$ 以及 $k$ 个特殊字符。可多次：删除特殊字符前面的字符, 直到不能删除为止。

问能操作多少次？

<p class="note note-info"> 一个例子 </p>

> $s = ``joobeel", S = \{``o", ``e"\}$
>
> $``\color{red}{jo}\color{black}{o}\color{red}{be}\color{black}{el}" \rightarrow ``\color{red}{o}\color{black}{el}" \rightarrow ``el"$

## 解答

不能操作，当且仅当特殊字符是第一个字符且是唯一一个特殊字符。

我们注意到，这个操作是贪心的，不是删除前面的所有字符（前面没有特殊字符时）就是删除到前面的特殊字符。

于是整个操作将会执行 $\max\left\{p_{i} - p_{i - 1}\right\}$ 次，即特殊字符间的最大间隔。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int n;
  std::string s;

  std::cin >> n >> s;

  int k;
  std::cin >> k;

  std::set<int> S;

  for (int i = 0; i < k; ++i) {
    char ch;
    std::cin >> ch;
    S.insert(ch);
  }

  int ans = 0;
  for (int i = 0, l = -1, r = 0; i < n; ++i) {
    if (S.count(s[i])) {
      std::tie(l, r) = std::tuple{r, i};
      ans = std::max(ans, r - l);
    }
  }

  std::cout << ans << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n \log n)$

Bonus: 直接记录所有位置即可。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int n;
  std::string s;

  std::cin >> n >> s;

  int k;
  std::cin >> k;

  std::bitset<26> S;

  for (int i = 0; i < k; ++i) {
    char ch;
    std::cin >> ch;
    S[ch - 'a'] = true;
  }

  int ans = 0;
  for (int i = 0, l = -1, r = 0; i < n; ++i) {
    if (S.test(s[i] - 'a')) {
      std::tie(l, r) = std::tuple{r, i};
      ans = std::max(ans, r - l);
    }
  }

  std::cout << ans << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n)$

# C. Where is the Pizza?
## 题意

给定两个排列 $\{A\} \{B\}$，以及一个序列 $\{D\}$。

生成一个排列 $\{C\}$，满足如果 $D_i \ne 0$ ，那么 $C_i = D_i$; 否则 $C_i \in \{A_i, B_i\}$。

$\{C\}$ 有多少种可能？

## 解答

连接 $A_i \rightarrow B_i$，因为是排列，所以总能形成若干联通块。

每一个联通块，同时必定也是环。对于每一个环，若有一个元素确定，那么整个环在 $\cal \{C\}$ 中也是确定的。

否则每个元素只有两种可能 $A_i \mathtt{\;or\;} B_i$。每个环都是独立的，因此答案为 $2 ^ {t}$，其中 $t$ 为环个数。

<details><summary>展开代码</summary>

```cpp
static constexpr int mod = 1'000'000'007;

void solve() {
  int n;
  std::cin >> n;

  std::vector<int> a(n), b(n), p(n);

  std::vector<bool> visited(n);

  for (auto &i : a) {
    std::cin >> i;
    i -= 1;
  }

  for (auto &i : b) {
    std::cin >> i;
    i -= 1;
  }

  for (int i = 0, d; i < n; ++i) {
    std::cin >> d;
    if (d != 0) {
      visited[a[i]] = visited[b[i]] = true;
    }
  }

  for (int i = 0; i < n; ++i) {
    p[a[i]] = b[i];
  }

  std::vector<bool> st(n);

  int ans = 1;

  for (int i = 0; i < n; ++i) {
    if (!st[i]) {
      int cnt = 0, flag = 0;
      for (int j = i; !st[j]; j = p[j]) {
        st[j] = true;
        cnt += 1;
        flag |= visited[j];
      }
      if (cnt != 1 && flag == false) {
        ans = 2ll * ans % mod;
      }
    }
  }

  std::cout << ans << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n)$

Bonus: 实际上是数点数大于 $2$ 并且没有被标记的联通块，使用并查集即可。

<details><summary>展开代码</summary>

![](/images/cf/cf788c.png)

</details>

> 复杂度： $\mathcal O(n \alpha (n))$

<p class="note note-primary"> Bonus2: <a href="https://atcoder.jp/contests/abc247/tasks/abc247_f">https://atcoder.jp/contests/abc247/tasks/abc247_f</a> </p>

# D. Very Suspicious
## 题意

在一个无限大的由六边形的平面上用直线（必须与六边形的某条边平行）分割出等边三角形,问要分割出 $n$
个等边三角形至少需要多少条直线。

![](/images/cf/cf788d.png)

## 解答

设三种方向的线分别有 $x, y, z$ 条，容易发现他们会交出 $(xy + yz + xz)$ 个点，这些点与六边形本来的边构成一系列（成对出现）等边三角形。

![](/images/cf/cf788d2.png)

我们熟知

$$
2 (xy + yz + xz) \le 2 (x ^ 2 + y ^ 2 + z ^ 2) \quad (``=" \mathrm{\;iff.\;} x = y = z)
$$

现在有 $x + y + z = n$, 均分出 $\left\langle\left\lfloor\dfrac{n}{3}\right\rfloor,\left\lfloor\dfrac{n + 1}{3}\right\rfloor, \left\lceil\dfrac{n}{3}\right\rceil\right\rangle$ 即可。

<details><summary>展开代码</summary>

```cpp
int tt;
for (std::cin >> tt; tt != 0; tt -= 1) {
  int n;
  std::cin >> n;

  i64 l = 0, r = 100'000;
  while (l + 1 < r) {
    i64 mid = (l + r) / 2;
    i64 x = mid / 3, y = (mid + 1) / 3, z = (mid + 2) / 3;
    if (2LL * (x * y + y * z + x * z) >= n) {
      r = mid;
    } else {
      l = mid;
    }
  }

  std::cout << r << '\n';
}
```

</details>

> 复杂度： $\mathcal O(T \log n)$

<p class="note note-info"> Bonus: <a href="http://oeis.org/A030511">http://oeis.org/A030511</a> </p>

<details><summary>展开</summary>

$$
\begin{cases}
a(n) = \dfrac{2 \times (n - 1)^2}{3} & if\; n \equiv 1 \pmod 3\\
\\
a(n) = \dfrac{2 \times n \times (n - 2)}{3} & \rm otherwise.\end{cases}
$$

</details>

# E. Hemose on the Tree
## 题意

给定一棵 $2 ^ p$ 个节点的树，给其点、边标注 $[1, 2n - 1]$ 的权，随后选择一个根。

使得根到其他点经过的点、边权之异或和的最大值最小。

## 解答

因为 $n = 2 ^ p$，于是 $2 n - 1 = 2 ^ {n + 1} - 1$。

可见最高位是 $p$，注意到整个值域关于 $n$ 对称，一个自然的想法是 $n \mathtt{\;xor\;} t \mathtt{\;xor\;} n + t = 0$。

即以 $n$ 为根，其他的数对称放置在点与边上即可, 这样就能使得权重或 $0$ 或 $n$, 分层构造之。

同时，因为先经过边，所以边上要放大的数抵消掉最高位，到下一层再反转过来就行了。

> 有没有更好的解呢？答案是否定的。取 $t \;(t \lt n)$ 做根，要使得异或出来的数字也是 $\lt n$
的，那么接下来每条边、每个点都需要是 $\lt n$ 的，这显然不行。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int p;
  std::cin >> p;

  int n = 1 << p;
  std::vector<std::vector<std::pair<int, int>>> G(n);

  for (int i = 0, u, v; i < n - 1; ++i) {
    std::cin >> u >> v;
    u -= 1, v -= 1;
    G[u].emplace_back(v, i);
    G[v].emplace_back(u, i);
  }

  std::vector<int> a(n), b(n - 1);

  a[0] = n;

  auto dfs = [&](auto &&self, int u, int p, bool v) -> void {
    for (auto &&[to, j] : G[u]) if (to != p) {
      if (v) {
        std::tie(b[j], a[to]) = std::tuple{to ^ n, to};
      } else {
        std::tie(b[j], a[to]) = std::tuple{to, to ^ n};
      }
      self(self, to, u, v ^ 1);
    }
  };

  dfs(dfs, 0, -1, 1);

  std::cout << "1\n";
  std::copy(a.begin(), a.end(), std::ostream_iterator<int>(std::cout, " "));
  std::cout << '\n';
  std::copy(b.begin(), b.end(), std::ostream_iterator<int>(std::cout, " "));
  std::cout << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n = 2 ^ p)$

# * F. Jee, You See?
## 题意

给定 $n, l, r, z$，问有多少长度为 $n$ 的序列 $s$ 满足：

 + $\displaystyle\sum_{i = l}^r{s[i]} \in [l, r]$
 + $\displaystyle\bigoplus_{i = l}^r{s[i]} = z$

## 解答

数位背包，待学。

<++>

<details><summary>展开代码</summary>

```cpp
int n;
i64 l, r, z;
std::cin >> n >> l >> r >> z;

std::vector<Z> choose(n + 1);
choose[0] = 1;
for (int i = 1; i <= n; i++) {
  choose[i] = choose[i - 1] * (n - i + 1) / i;
}

auto solve = [&](i64 r) {
  std::vector<Z> dp(n + 1);
  dp[0] = 1;
  for (int i = 59; i >= 0; i--) {
    int d = r >> i & 1;
    int u = z >> i & 1;
    std::vector<Z> g(n + 1);
    for (int j = 0; j <= n; j++) {
      int k = 2 * j + d;
      for (int x = u; x <= n && x <= k; x += 2) {
        int l = std::min(n, k - x);
        g[l] += dp[j] * choose[x];
      }
    }
    dp = g;
  }
  return std::accumulate(dp.begin(), dp.end(), Z(0));
};

std::cout << (solve(r) - solve(l - 1)).val() << "\n";
```

</details>

> 复杂度： $\mathcal O(n ^ 2 \log n)$
