---
title: cf786
permalink: /cf/786/
categories: cf
tags: [Kahn, 拓扑排序]
toc: true
math: true
date: 2022-05-03 06:12:38
updated:
---

[https://codeforces.com/contest/1674](https://codeforces.com/contest/1674)

# A. Number Transformation
## 题意

给定 $x, y$。试给出 $(a, b)$ 表示通过对 $x$ 乘以 $b ^ a$ 将 $x$ 转变为 $y$，或回答不可能。

## 解答

$x \le y \land x \mid y$ 时有解，$(1, \dfrac{y}{x})$ 是可满足的一组解。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int a, b;
  std::cin >> a >> b;

  if (b % a != 0 || b < a) {
    return std::cout << "0 0\n", void();
  }

  std::cout << 1 << ' ' << (b / a) << '\n';
}
```

</details>

> 复杂度： $\mathcal O(1)$

# B. Dictionary
## 题意

两个不同字母组成的集合中，给定的 $s$ 居于第几？

## 解答

注意到 $26 ^ 2 - 26 = 650$，非常小。预处理出来这个集合也是可以接受的。

<details><summary>展开代码</summary>

```cpp
void solve() {
  static bool initialized = false;
  static std::map<std::array<char, 2>, int> mp;
  if (!initialized) {
    initialized ^= 1;
    int idx = 1;
    for (int i = 0; i < 26; ++i) {
      for (int j = 0; j < 26; ++j) {
        if (i == j) {
          continue;
        } else {
          std::array<char, 2> c;
          c[0] = 'a' + i;
          c[1] = 'a' + j;
          mp[c] = idx ++;
        }
      }
    }
  }

  std::array<char, 2> c;
  for (auto &ch : c) {
    std::cin >> ch;
  }

  std::cout << mp[c] << '\n';
}
```

</details>

> 复杂度： $\mathcal O(|\Sigma| ^ 2 + T \log |\Sigma|)$

--------

Bonus: 此集合实为 $26$ 进制「抠掉」所有 $a = b$ 的点。因此可以关于 $a <\!\!\!\!?\;\; b$ 分类讨论。

<details><summary>展开代码</summary>

```cpp
void solve() {
  char a, b;
  std::cin >> a >> b;
  a -= 'a', b -= 'a';

  std::cout << 25 * a + b - (b > a) + 1 << '\n';
}
```

</details>

> 复杂度： $\mathcal O(1)$


# C. Infinite Replacement
## 题意

给定两个字符串 $s, t$，其中 $s$ **全为** `a`。你可以多次将某个 `a` 替换为 $t$，问有多少种可能的字符串？

或回答有无穷多种。

## 解答

如果 $t = ``a"$，那么总有最初的那一种。如果替换上去的部分依然包含 $``a"$，那么有无穷多种可能。正如：

```python
print('{}'.format('{}').format('{}').format('{}').format('{}'))
```

否则（$``a" \notin t$）, 原串中的每一个位置都可以选择换或者不换，于是方案数为 $2 ^ n$。

<details><summary>展开代码</summary>

```cpp
void solve() {
  std::string s, t;
  std::cin >> s >> t;

  if (std::count(t.begin(), t.end(), 'a') != 0) {
    if (t == "a") {
      return std::cout << "1\n", void();
    } else {
      return std::cout << "-1\n", void();
    }
  }

  std::cout << (1LL << s.size()) << '\n';
}
```

</details>

> 复杂度： $\mathcal O(|t|)$

# D. A-B-C Sort
## 题意

给定数组 $\{A\}$，以及两个空数组 $\{B\}, \{C\}$。执行下面的算法之后，$\{C\}$ 是否能变为单调不减的序列？

![](/images/cf/cf786d.png)

<details><summary>这一段的 LaTeX 代码</summary>

```latex
\def\SetClass{article}
\documentclass{\SetClass}
\usepackage[lined,boxed,commentsnumbered]{algorithm2e}
\begin{document}
\begin{algorithm}[H]
  \SetAlgoLined
%%  \KwData{ \{ A \}}
%%  \KwResult{}

  \While{ \{A\} is not empty }{
    \eIf{ \{B\} is odd long }{
      $p \leftarrow$ B[middle - 1] or B[middle + 1]
    }{
      $p \leftarrow$ B[middle]
    }
    move last element of \{A\} to B$_p$
  }

  \While{ \{B\} is not empty }{
    \eIf{ \{B\} is even long }{
      $p \leftarrow$ B[middle - 1] or B[middle + 1]
    }{
      $p \leftarrow$ B[middle]
    }
    append B$_p$ to the end of \{C\}
  }
  \caption{A-B-C Sort Algorithm}
\end{algorithm}
\end{document}
```

</details>


## 解答

上述算法两个步骤基本互逆，这使得我们 **只能调整相邻的元素**。

模拟即可，但需要注意到 $[1, 2, 1] \rightarrow [1, 1, 2]$。

<details><summary>展开代码</summary>

```cpp
void solve() {
  int n;
  std::cin >> n;
  std::vector<int> a(n);

  for (auto &i : a) {
    std::cin >> i;
  }

  for (int i = n - 2; i >= 0; i -= 2) {
    if (a[i] > a[i + 1]) {
      std::swap(a[i], a[i + 1]);
    }
  }

  std::cout << (std::is_sorted(a.begin(), a.end()) ? "yes\n" : "no\n");
}
```

</details>

> 复杂度： $\mathcal O(n)$

Bonus: 赛时代码。

<details><summary>展开代码</summary>

```cpp
std::vector<int> b;

for (int i = 0; i < n; ++i) {
  if ((n - i) % 2 == 0 && a[i] > a[i + 1]) {
    std::swap(a[i], a[i + 1]);
  }
  b.push_back(a[i]);
}

std::cout << (std::is_sorted(b.begin(), b.end()) ? "YES\n" : "NO\n");
```

</details>


# E. Breaking the Wall

> 本题 Hacked 数高达 $1500^+$。

## 题意

给定一个数组 $\{A\}$，你可多次选择单点 $-2$，相邻元素（如果有）将会 $-1$。

问至少需要打击多少次才会出现至少两个位置 $< 0$ ？

## 解答

枚举这俩可能的情况：

 + 两者相邻：$[1, 2, 1]$ 或者 $[1, 3, 3, 1]$ 打击。

 + 隔着一个：$[1, 2, 1]$ 打击。$a, b\; (a \le b), a + \left\lceil\dfrac{b - a}{2}\right\rceil$

 + 离得很远：选择最小的两元素多次单点打击。

<details><summary>展开代码</summary>

```cpp
int main() {
  int n;
  std::cin >> n;

  auto C = [&](int n, int d = 2) {
    return (n + d - 1) / d;
  };

  std::vector<int> a(n);

  int m1 = INT_MAX, m2 = INT_MAX;

  for (auto &i : a) {
    std::cin >> i;
    if (i < m1) {
      std::tie(m1, m2) = std::tuple{i, m1};
    } else if (i < m2) {
      m2 = i;
    }
  }

  int ans = C(m1) + C(m2);

  for (int i = 0; i < n - 1; ++i) {
    int A = a[i], B = a[i + 1];
    ans = std::min(ans, std::max({ C(A), C(B), C(A + B, 3) }));
  }

  for (int i = 0; i < n - 2; ++i) {
    int A = a[i], B = a[i + 2];
    if (A > B) {
      std::swap(A, B);
    }
    ans = std::min(ans, A + C(B - A, 2));
  }

  std::cout << ans << '\n';

  return 0 ^ 0;
}
```

</details>

> 复杂度： $\mathcal O(n)$

# F. Desktop Rearrangement
## 题意

在二维矩阵上有一些 $``\star"$ 与 $``\cdot"$。

给出多组询问, 将 $(x, y)$ 格点的符号反转，即 $``\star" \leftrightarrow ``\cdot"$ 之后，回答将当前桌面上的 $``\star"$
从左到右、从上到下排布整齐至少需要移动多少个 $``\star"$ ？

**这个修改是永久的**。

## 解答

最小花费就是不在前 **tot** 个位置的星星个数。

对于每次修改，只会增加或者减少一个星星，因此每次回答都是 $\mathcal O(1)$ 的。

<details><summary>展开代码</summary>

```cpp
int main() {
  std::cin.tie(nullptr)->sync_with_stdio(false);

  int n, m, q;
  std::cin >> n >> m >> q;

  std::vector<bool> possessed(n * m);

  int cnt = 0, o = 0;

  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
      char ch;
      std::cin >> ch;
      if (ch == '*') {
        if (possessed[cnt]) {
          o += 1;
        }
        cnt += 1;
        possessed[j * n + i] = 1;
        if (j * n + i < cnt) {
          o += 1;
        }
      }
    }
  }

  for (int x, y; q != 0; --q) {
    std::cin >> x >> y;
    int i = -- y * n + -- x;

    if (possessed[i]) {
      if (i < cnt) {
        o -= 1;
      }
      cnt -= 1;
      possessed[i].flip();
      if (possessed[cnt]) {
        o -= 1;
      }
    } else {
      if (possessed[cnt]) {
        o += 1;
      }
      cnt += 1;
      possessed[i].flip();
      if (i < cnt) {
        o += 1;
      }
    }

    std::cout << cnt - o << '\n';
  }

  return 0 ^ 0;
}
```

</details>

> 复杂度： $\mathcal O(n \times m + q)$

# G. Remove Directed Edges
## 题意

给定一张 $\rm DAG$，删去若干边，使得每个点：

+ 若原有出边，则至少删去一条。
+ 若原有入边，则至少删去一条。

随后选取子图 $\{S\}$，其中的任两点之间可达（单方面到达即可）。求 $\left|S\right|$ 最大是多少。

## 解答

删哪些边？那些入、出度为 $1$ 的点必须删除, 所以入、出度同时为 $1$ 的点一定不会成为答案。

剩下的点，即使不与最终的 $\{S\}$ 联通也无关紧要, 因为最后需要求解的子图也是 $\rm DAG$，其最长链即为所求, $dp$ 会解决掉这些情况。

$dp$ 的过程实际上就是遍历 $DAG$, 使用拓扑排序的 Kahn 算法即可。

<details><summary>展开代码</summary>

```cpp
static const int N = 200'007;

std::pair<int, int> e[N];
int deg[N][2];
int nd[N];
int dp[N];
std::vector<int> v[N];

int main() {
  std::cin.tie(nullptr)->sync_with_stdio(false);

  int n, m;
  std::cin >> n >> m;

  for (int i = 1; i <= m; ++i) {
    auto &[x, y] = e[i];
    std::cin >> x >> y;
    ++ deg[x][0], ++ deg[y][1];
  }

  for (int i = 1; i <= m; ++i) {
    auto &[x, y] = e[i];
    if (deg[x][0] != 1 and deg[y][1] != 1) {
      v[x].push_back(y);
      ++ nd[y];
    }
  }

  std::queue<int> q;
  for (int i = 1; i <= n; ++i) {
    if (!nd[i]) {
      q.push(i);
      dp[i] = 1;
    }
  }

  int ans = -1;

  while (q.size()) {
    int t = q.front();
    q.pop();
    ans = std::max(ans, dp[t]);
    for (auto &&i : v[t]) {
      dp[i] = std::max(dp[i], dp[t] + 1);
      if (-- nd[i] == 0) {
        q.push(i);
      }
    }
  }

  std::cout << ans << '\n';

  return 0 ^ 0;
}
```

</details>

> 复杂度： $\mathcal O(n + m)$
