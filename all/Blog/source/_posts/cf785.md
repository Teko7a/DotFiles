---
title: cf785
permalink: /cf/785/
categories: cf
tags: [todo, 循环节, 五边形数, 背包计数, 数论, crt, dp]
toc: true
math: true
date: 2022-05-02 01:46:14
updated:
---

[https://codeforces.com/contest/1673](https://codeforces.com/contest/1673)

> 邓老师说，给自己看的题解要写的简练一些。这样回头看的时候也会轻松许多。

# A. Subtle Substring Subtraction
## 题意

给定字符串 $s$, 并定义字符串的 **权重** 为其字符顺序之和。如 `w("aba") = 1 + 2 + 1`。

博弈，先手可取走 $s$ **偶数长度** 的子串，并获得其权重，而后者则可取走 **奇数长度** 的。无法行动时分高者胜。问：

1. 谁胜？
2. 两人获得的 **权重差** 最大为多少？

## 解答

如果 $s$ 仅含一个字符，先手无法行动，于是后手胜。

偶数长度，先手胜，并获得全部字符串。

奇数长度，先手也可取得 `s[1:]` 或者 `s[:-1]`，容易发现得分不会劣于后手，因而先手总胜。

<details><summary>展开代码</summary>

```cpp
void solve() {
  std::string s;
  std::cin >> s;

  int ans = 0;
  for (auto &ch : s) {
    ch -= 'a' - 1;
    ans += ch;
  }

  if (s.size() == 1) {
    return std::cout << "Bob " << ans << '\n', void();
  }

  if (s.size() & 1) {
    ans -= 2 * std::min(s[0], s.back());
  }

  std::cout << "Alice " << ans << '\n';
}
```

</details>

> 复杂度： $\mathcal O(n)$

# B. A Perfectly Balanced String?
## 题意

定义字符串 “平衡”，当且仅当其任意两字符 $a, b$ 满足在任意子串中出现频数相差不大于 $1$。

判断给定的字符串是否 “平衡”。

## 解答

> 注意到 $a \star a$ 及不在 $\star$ 中的一个字符 $x$ 总是不满足条件的。如在 $``abcak"$ 中选择三元组 $\left \langle ``abca", ``a", ``k" \right \rangle$。
> 如果不存在这样的情形，则一定 “平衡”：组成该字符串的子串均 “平衡”，则该串也如此。
> 在 $\mathcal O(\left|\Sigma\right| \times n)$ 检验这一点是容易的，但 ”平衡” 串具有一个优美的性质：

其 **必有循环节** （注意 $``aba"$ 也是循环的, 即存在 $k$ 使得 $s[i + k] = s[i]$, 其中 $i$ 遍历 $1 \sim n - k$）。

--------

证明：

$a \star a ?$：如果 $? \not\in \star$，则不平衡。

反之 $\star$ 遍历所有非 $a$ 字符， 若 $\star[1] \ne\; ?$，取 $\left \langle ``\star[x:]?", ``\star[0]", ``?"
\right \rangle, \mathtt{\;where\;} \star[x] = ?$ 也不平衡。

因此必有 $\star[0] =\; ?$。

--------

<details><summary>展开代码</summary>

```cpp
void solve() {
  std::string s;
  std::cin >> s;

  int n = s.size(), len = s.size();
  static char * str = new char [200007];

  std::strcpy(str + 1, s.data());

  std::array<int, 26> pos{};
  for (int i = 1; i <= n; ++i) {
    int si = str[i] - 'a';
    if (pos[si] != 0) {
      len = i - pos[si];
      break;
    }
    pos[si] = i;
  }

  for (int i = 1; i + len <= n; ++i) {
    if (str[i] != str[i + len]) {
      return std::cout << "NO\n", void();
    }
  }

  std::cout << "YES\n";
}
```
</details>

> 复杂度： $\mathcal O(n)$

# C. Palindrome Basis
## 题意

整数划分问题，限制其中每个数都是回文的。

 - $n \le 4 \times 10 ^ 4$

## 解答

处理出所有的回文数，随后进行整数划分（完全背包计数 / [五边形数](https://studyingfather.com/archives/3000)）。

> 表白 `SF`, /qq /xin

<style>
.rated-user {
  font-family: helvetica neue, Helvetica, Arial, sans-serif;
  text-decoration: none !important;
  font-weight: 700;
  display: inline-block;
}

.user-legendary {
  color: red !important;
}

.user-legendary::first-letter {
  color: #000 !important;
}
</style>

> 注：其中 `Z` 为 [<font class="rated-user user-legendary">jiangly</font>](https://codeforces.com/profile/jiangly) 的整数模板类。

<details><summary>展开代码</summary>

```cpp
void solve() {
  static bool initialized = false;
  static std::vector<int> palind;
  static const int N = 4E4 + 7;
  // static std::array<Z, N> dp{}; -> 寄！
  static Z dp[N];
  if (!initialized) {
    initialized ^= 1;
    for (int i = 1; i <= N - 7; ++i) {
      auto s = std::to_string(i);
      if (s == std::string(s.rbegin(), s.rend())) {
        palind.push_back(i);
      }
    }

    dp[0] = 1;
    for (auto &&num : palind) {
      for (int i = 0; i + num <= N - 7; ++i) {
        dp[i + num] += dp[i];
      }
    }
  }

  int n;
  std::cin >> n;
  std::cout << dp[n] << '\n';
}
```
</details>

> 复杂度： $O(n \times p), p$ 为回文数个数，非常小。

# D. Lost Arithmetic Progression
## 题意

有两个 $A.P. \{A\}, \{B\}$，给出 $\{B\}$ 以及 $\{A\} \bigcap \{B\}$，问 $\{A\}$ 有多少种可能。

或回答有无穷多个。

## 解答

首先如果 $B_0 \gt C_0$ 或者 $B_{-1} \lt C_{-1}$ 是不可以的，此时 $\{C\}$ 不合法。

在此基础上，如果 $d_B \nmid C_0 - B_0$ 也不行（即 $\{B\} \bigcap \{C\} = \varnothing$）。

--------

设 $\{A\} = a + c \times \Z, \{B\} = b + d \times \Z$, 如何求其交？下面是一个例子：

$$
\begin{cases}
N = 5 n + 3 \\
N = 7 n - 2
\end{cases} \Rightarrow
\begin{cases}
N \equiv 3 \pmod 5 \\
N \equiv 5 \pmod 7
\end{cases} \Rightarrow_{\gcd(5, 7) = 1}
N \equiv 33 \pmod {35}
$$

注意到第二部分有唯一解当且仅当 $\gcd(c, d) \mid \small | a - b \small |$ (裴蜀定理)。

由中国剩余定理（或拓欧）可得，$\dfrac{cd}{\gcd(c, d)} = \mathrm{lcm}(c, d)$ 为解的模数，即公差。

于是我们找到了另一组不合法的情况：$d_B \nmid d_C$。

--------

如果 $\{C\}$ 的首项的前一项 $C_0 - d_C \lt B_0$，或者最后一项 $C_{-1} + d_C \gt B_{-1}$ 时，$\{A\}$
可以无限左右拓展。

否则有限组解，给定了 $\{A\} \bigcap \{B\}$，于是从倍数转换成了约数。

对于 $d_C$ 的约数，方案左右独立，根据乘法原理计算：

$$
\sum_{\mathrm{lcm}(p, d_B) = d_C}\left( \dfrac{d_C}{p}\right)^2
$$

<details><summary>展开代码</summary>

```cpp
void solve() {
  i64 b, q, y, c, r, z;
  std::cin >> b >> q >> y >> c >> r >> z;

  i64 lb = c + (z - 1) * r, lc = b + (y - 1) * q;

  if (r % q || (c - b) % q || c < b || lb > lc) {
    return std::cout << "0\n", void();
  } else if (c - r < b || lb + r > lc) {
    return std::cout << "-1\n", void();
  }

  Z ans = 0;
  for (i64 i = 1; i * i <= r; ++i) {
    if (r % i == 0) {
      if (std::lcm(i, q) == r) {
        ans += r / i * r / i;
      }
      if (i * i != r) {
        i64 t = r / i;
        if (std::lcm(t, q) == r) {
          ans += r / t * r / t;
        }
      }
    }
  }

  std::cout << ans << '\n';
}
```
</details>

> 复杂度： $\mathcal O(\sqrt n \lg n)$

# * E. Power or XOR?
## 题意

<++>

## 解答

<++>

<details><summary>展开代码</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
constexpr int mod = 1'000'000'007;
void add(int &x, int y) {
  if ((x += y) >= mod) {
    x -= mod;
  }
}
int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n, k;
  cin >> n >> k;

  vector<int> B(n);
  for (int &Bi : B) {
    cin >> Bi;
  }

  vector<int> ans(1 << 20);
  map<pair<int, int>, int> F;

  auto f = [&](int n, int k) {
    if (F.count({n, k})) {
      return F[{n, k}];
    }
    int &res = F[{n, k}];
    for (int i = k; i <= n; i += 1) {
      res ^= (n & i) == i;
    }
    return res;
  };

  for (int i = 0; i < n; i += 1)
    for (int j = i; j < i + 20 and j < n; j += 1) {
      LL x = 0;
      for (int k = i + 1; k <= j; k += 1) {
        x += B[k];
      }
      if (x >= 20) {
        break;
      }
      x = 1 << x;
      x *= B[i];
      if (x >= (1 << 20)) {
        break;
      }
      int s = (i != 0) + (j + 1 != n);
      if (f(n - 1 - (j - i) - s, k - s)) {
        ans[x] ^= 1;
      }
    }

  int one = 0;
  for (int i = (1 << 20) - 1; i >= 0; i -= 1) {
    if (ans[i]) {
      one = 1;
    }
    if (one) {
      cout << ans[i];
    }
  }
  if (not one) {
    cout << 0;
  }
  return 0;
}
```
</details>

> 复杂度： $<++>$

# * F. Anti-Theft Road Planning
## 题意

<++>

## 解答

<++>

<details><summary>展开代码</summary>

```cpp
#include <bits/stdc++.h>

using namespace std;

int G[32];

int key(int x, int y) {
  int t = 0;
  x = G[x];
  y = G[y];
  for (int i = 0; i < 5; i++) {
    t |= ((x >> i & 1) << (2 * i)) | ((y >> i & 1) << (2 * i + 1));
  }
  return t;
}

int main() {
  G[0] = 0;
  for (int k = 2; k <= 32; k <<= 1) {
    for (int i = 0; i < k / 2; i++) {
      G[k - i - 1] = (k / 2) | G[i];
    }
  }
  int n, k;
  scanf("%d%d", &n, &k);
  for (int i = 0; i < n; i++) {
    for (int j = 1; j < n; j++) {
      printf("%d ", key(i, j - 1) ^ key(i, j));
    }
    putchar('\n');
  }
  for (int i = 1; i < n; i++) {
    for (int j = 0; j < n; j++) {
      printf("%d ", key(i - 1, j) ^ key(i, j));
    }
    putchar('\n');
  }
  fflush(stdout);
  int x = key(0, 0);
  while (k--) {
    int v;
    scanf("%d", &v);
    x ^= v;
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        if (key(i, j) == x) {
          printf("%d %d\n", i + 1, j + 1);
        }
      }
    }
    fflush(stdout);
  }
  return 0;
}
```
</details>

> 复杂度： $<++>$

